# Dependency Injection

Dependency Injection (DI) is a core design pattern we use throughout the backend architecture to promote loose coupling and enhance testability. Instead of creating dependencies within a class, we "inject" them from an external source, typically through the class constructor.

## How We Use Dependency Injection

In our layered architecture, higher-level components depend on lower-level abstractions. For example, a `UserService` depends on a `UserRepository`.

-   **Constructor Injection**: Dependencies are provided as arguments to the constructor.
-   **Default Instances**: We provide a default, singleton instance of the dependency, which is used in production.
-   **Testability**: During testing, we can easily provide a mock or stub version of the dependency.

### Example

Consider the relationship between `UserService` and `UserRepository`.

**1. `UserRepository` (The Dependency)**

This class provides data access methods.

```typescript
// /src/modules/userSystem/user.repository.ts

export class UserRepository {
  async getUserById(userId: string) {
    // ... database logic
  }
}

// Default production instance
export const userRepository = new UserRepository();
```

**2. `UserService` (The Consumer)**

The `UserService` receives the `UserRepository` through its constructor.

```typescript
// /src/modules/userSystem/user.service.ts
import { UserRepository, userRepository } from "./user.repository.js";

export class UserService {
  // The dependency is injected via the constructor
  constructor(private userRepository: UserRepository = userRepository) {}

  async fetchUser(userId: string) {
    // The service uses the injected repository
    return this.userRepository.getUserById(userId);
  }
}
```

## Benefits of This Approach

1.  **Decoupling**: The `UserService` is not tightly coupled to a specific implementation of `UserRepository`. It only knows about the repository's interface (the methods it can call).
2.  **Testability**: When testing `UserService`, we can inject a mock `UserRepository` to isolate the service from the database and control the test conditions.

**Example: Testing the `UserService`**

```typescript
// /src/modules/userSystem/user.service.test.ts
import { UserService } from "./user.service.js";

// 1. Create a mock repository
const mockUserRepository = {
  getUserById: jest.fn().mockResolvedValue({
    id: '123',
    name: 'Test User'
  }),
};

// 2. Inject the mock into the service
const userService = new UserService(mockUserRepository as any);

// 3. Test the service logic in isolation
it('should fetch a user correctly', async () => {
  const user = await userService.fetchUser('123');

  // Assert that the mock was called
  expect(mockUserRepository.getUserById).toHaveBeenCalledWith('122');
  // Assert the result
  expect(user.name).toBe('Test User');
});
```

By consistently applying this pattern, we create a more flexible and maintainable codebase that is easy to test and evolve.
