 




### for functions 
functions must either return a result or throw an error otherwise. 

when throwing an error, make sure to use the ServerError class from /src/classes/ServerError.ts or its subclasses for better error handling. 

any error thrown within the application will be caught by the global error handler. 

the error handler will then return the appropriate message to the api caller depending on the type of error. 

```typescript 
// apps/nexus-api/src/modules/userSystem/user.repository.ts

  getUserById = async (userId: string): Promise<userRow> => {
    const { data, error } = await supabase
      .from(this.tableName)
      .select("*")
      .eq("id", userId)
      .single();

// throw error if it exists
    if (error) throw new DatabaseError(error.message);

// return the data of there is no error
    return data;
  };

```

### when calling functions 
when calling functions, you must use the tryCatch function to properly catch error that might happen inside the function that you are calling.

try catch will automatically catch instances of ServerError, add context to it, and throw it again to propagate it outwards until it reaches the global error handler. 

if it catches an unknown error, it will simply return it as a variable, allowing you to decide how to handle the error. 
```typescript
// apps/nexus-api/src/modules/userSystem/user.service.ts
import { tryCatch } from "@/utils/tryCatch.util.js";

getUserById = async (userId: string) => {

    const { data, error } = await tryCatch( 
      async () => await this.userRepository.getUserById(userId), // pass a function that will do the work
      "getting user", // explain the context or why are you calling the function
    );

// handle unknown error by classifying it and throwing it again to be caught by the global error handler
if (error && )
    if (error) throw new RepositoryError(error.message);
 

// return the data of there is no error
    return data;
  };

```