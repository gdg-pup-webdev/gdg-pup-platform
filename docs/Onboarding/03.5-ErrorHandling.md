# Error Handling Strategy

A robust error handling strategy is crucial for building a reliable application. Our approach is centered around centralized error management, custom error classes, and a utility for safely executing functions.

## 1. Throwing Errors

Functions should either return a result successfully or throw an error. When an error condition is met, you should throw an instance of our custom `ServerError` class (or one of its subclasses).

Using custom error classes allows us to attach more context to our errors and handle them programmatically.

-   `ServerError`: Base class for all application-specific errors.
-   `DatabaseError`: For errors related to database operations.
-   `ServiceError`: For errors occurring within the business logic layer.
-   `ControllerError`: For errors in the request handling layer.

Any error thrown within the application will be caught by our global error handler middleware, which then formats and sends an appropriate response to the API caller.

**Example: Throwing an error in a repository**

```typescript
// apps/nexus-api/src/modules/userSystem/user.repository.ts
import { DatabaseError } from "@/classes/ServerError.js";
import { supabase } from "@/lib/supabase.js";
import { Tables } from "@/types/supabase.types";

type UserRow = Tables<"user">;

export class UserRepository {
  // ...

  async getUserById(userId: string): Promise<UserRow> {
    const { data, error } = await supabase
      .from(this.tableName)
      .select("*")
      .eq("id", userId)
      .single();

    // If the database operation fails, throw a specific error
    if (error) {
      throw new DatabaseError(error.message);
    }

    return data;
  }
}
```

## 2. Catching Errors with `tryCatch`

When calling a function that may throw an error, always wrap it with our custom `tryCatch` utility. This utility helps standardize error handling across the application.

-   **How it works**:
    -   It takes a function to execute and an optional context message.
    -   If the function executes successfully, it returns `{ data, error: null }`.
    -   If the function throws a known `ServerError`, `tryCatch` re-throws it to be caught by the global error handler while attaching the passed context.
    -   If the function throws an *unknown* error (e.g., a native `TypeError`), it catches the error and returns `{ data: null, error }`. This allows you to decide how to handle the unexpected errors.

**Example: Using `tryCatch` in a service**

```typescript
// apps/nexus-api/src/modules/userSystem/user.service.ts
import { tryCatch } from "@/utils/tryCatch.util.js";
import { UserRepository, userRepository } from "./user.repository.js";
import { RepositoryError, ServiceError } from "@/classes/ServerError.js";

export class UserService {
  constructor(private userRepository: UserRepository = userRepository) {}

  async getUserById(userId: string) {
    const { data, error } = await tryCatch(
      // 1. Pass the function to execute
      () => this.userRepository.getUserById(userId),
      // 2. Provide context for better error logging
      "Error fetching user from the database."
    );

    // 3. Handle any unexpected, unknown errors
    if (error) {
      // Classify the unknown error and re-throw it
      throw new ServiceError("An unexpected error occurred in the user service.", {
        cause: error
      });
    }

    // 4. Return the data on success
    return data;
  }
}
```

By following this pattern, we ensure that all errors are handled consistently, providing clear and informative feedback to developers and API consumers while preventing unexpected crashes.